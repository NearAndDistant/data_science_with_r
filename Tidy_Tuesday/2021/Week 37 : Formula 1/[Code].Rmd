---
title: "Formula 1"
author: "NearAndDistant"
date: "07/09/2021"
output: html_document
---

Adding power makes you faster on the straights. Subtracting weight makes you faster everywhere.
- Colin Chapman

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##### Design
```{r}
library(showtext); showtext_auto()

font_add_google("Timmana" , "timmana")
text <- "timmana"

```


#### Glue
Glue offers interpreted string literals that are small, fast, and dependency-free. Glue does this by embedding R expressions in curly braces which are then evaluated and inserted into the argument string. We can use this to dynamically call the Ergast API. For instance:

name <- "Fred"
glue::glue('My name is {name}.')

#### Dynamically Import from Ergast API using Glue
```{r}
library(tidyverse)
library(jsonlite)
library(httr)

ergast_url <- "http://ergast.com/api/f1/{api_ask}.json?limit=5000"

api_ask <- "drivers"

raw_json_drivers_info <- 
  httr::GET(glue::glue(ergast_url)) %>% 
  content(type = "text", encoding = "UTF-8") %>% 
  jsonlite::parse_json(simplifyVector = FALSE)

```

#### Rectangling and tidyr
Rectangling is the art and craft of taking a deeply nested list (often sourced from wild caught JSON or XML) and taming it into a tidy data set of rows and columns. There are three functions from tidyr that are particularly useful for rectangling:

unnest_longer() takes each element of a list-column and makes a new row.
unnest_wider() takes each element of a list-column and makes a new column.
unnest_auto() guesses whether you want unnest_longer() or unnest_wider().

hoist() is similar to unnest_wider() but only plucks out selected components, and can reach down multiple levels. A very large number of data rectangling problems can be solved by combining these functions with a splash of dplyr.

```{r}
library(listviewer)

# creates interactive json map so we can see where we are
jsonedit(raw_json_standings)

```

#### Driver Info Table
```{r}

# create tibble of list of lists to unnest
json_drivers <- tibble(drivers = raw_json_drivers_info$MRData$DriverTable)

# unnest tibble into unnested lists then widen
drivers_info <- 
json_drivers %>%
  unnest_longer(drivers) %>% 
  unnest_wider(drivers) %>%
  select(-url) # we do not need Wikipedia entries for this project

```

##### Drivers Info: Graphic
```{r}
theme_set(theme_minimal())

drivers_info %>%
  count(nationality) %>%
  ggplot(aes(n , reorder(nationality, n), fill = nationality)) +
  geom_col(show.legend = FALSE) +
  labs(y = NULL)

```

#### F1 Seasons
```{r}

api_ask <- "seasons"

raw_json_seasons <- 
  httr::GET(glue::glue(ergast_url)) %>% 
  content(type = "text", encoding = "UTF-8") %>% 
  jsonlite::parse_json(simplifyVector = FALSE) 

json_seasons <- tibble(season = raw_json_seasons$MRData$SeasonTable)

seasons <- 
json_seasons %>%
  unnest_longer(season) %>% 
  unnest_wider(season) %>%
  select(-url)

```

#### Driver Standing Table
```{r}

seasons_vector <- unlist(seasons)

season_list_master <- tibble()

for(i in seasons_vector){
api_ask <- paste0(i,"/driverStandings")

raw_json_standings <- 
  httr::GET(glue::glue(ergast_url)) %>% 
  content(type = "text", encoding = "UTF-8") %>% 
  jsonlite::parse_json(simplifyVector = FALSE) 

# create tibble of list of lists to unnest
season_list <- tibble(season = raw_json_standings$MRData$StandingsTable$StandingsLists[[1]]$DriverStandings)

# unnest tibble into unnested lists then widen
season_list <- season_list %>% unnest_wider(season) %>% mutate(season = i)

season_list_master <- rbind(season_list_master , season_list)
}

```

#### Unnesting Seasons
```{r}

f1_complete <-
season_list_master %>%
  unnest(Constructors) %>%
  unnest_wider(Constructors) %>%
  select(-url , constructor = name , con_nationality = nationality) %>%
  unnest_wider(Driver) %>%
  select(season , everything(), -url, -positionText) %>%
  mutate(points = as.numeric(points) , 
         wins   = as.numeric(wins)) %>%
  janitor::clean_names()

# Vector of Constructors
constructor_list <- unlist(unique(f1_complete$constructor))

```

##### F1 Constructor Points
```{r}

f1_tot_points <- 
f1_complete %>%
  group_by(season , position , constructor) %>%
  summarise(tot_points = sum(as.numeric(points))) %>%
  group_by(season) %>%
  mutate(pc_point = tot_points / sum(tot_points)) %>%
  filter(tot_points != 0)

f1_season_winners <-
  f1_tot_points %>%
  group_by(season) %>%
  mutate(tot_points = sum(tot_points)) %>%
  mutate(constructor = paste("Winner:", constructor)) %>%
  mutate(constructor = if_else(season == "1954" & constructor == "Winner: Maserati", "Joint: Masterati & Mercedes", constructor)) %>%
  filter(position == 1, season != "1954" | constructor != "Winner: Mercedes")

```

##### F1 Constructor Graphic
```{r}

f1_tot_points %>%
  ggplot(aes(pc_point , season , fill = constructor)) +
  geom_col(position = "stack" , show.legend = FALSE) +
  scale_fill_viridis_d() + 
  geom_text(data = f1_season_winners , x = 1.01 , aes(y = season , label = constructor) , hjust = 0 , family = text) + 
  scale_x_continuous(labels = scales::percent) +
  labs(x = "Season Total Points" , 
       y = NULL) +
  theme(
        panel.grid = element_blank(),
        axis.text = element_text(family = text, size = 12),
        axis.text.y = element_text(margin = margin(r = -45))
        )

```

```{r}
[which(f1_tot_points$position == "1")]

  # https://datavizpyr.com/direct-labeling-with-secondary-axis-trick-ggplot2-r/
  #geom_text(data = f1_season_winners , 
  #          aes(x = reorder(season, -season) , y = tot_points , 
  #              label = paste0("Winner: " , f1_tot_points$constructor[which(f1_tot_points$position == "1")])),
  #          hjust = -0.1, size = 3) + 
```

